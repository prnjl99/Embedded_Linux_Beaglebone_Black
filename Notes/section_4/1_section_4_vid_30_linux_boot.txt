Control flow during linux boot ( 0:43 at section 4 vid 30 )

let's talk about the Linux boot sequences, after getting control from the U-Boot. let see, how exactly U-boot hands off the control to the Linux kernel. Take a look into this flow control diagram from U-Boot to Linux to launching of the very first application . U boot hands off the control to the head.s file in the boot strap loader of the Linux. the head.s calls miscellaneous.c (misc.c) file. That also belongs to the bootstrap loader to uncompress the compressed image. Then the control comes to another head.s file of the Linux kernel. And from head.s file of the Linux kernel, the control comes to the main.c file of the Linux kernel, and from main.c file, the first application of the Linux kernel that is init is launched. So, this is the flow from U boot to Linux to ntu Linux to launching of the first application.

First let's see, how U-boot hands off control to the Boot Strap Loader of the Linux kernel. For that, let's go to the "bootm.c" file of the U-Boot source code. Now, I am opening file called bootm.c from the U-boot source code. I've also attached the U-Boot source code in this lecture. file is present at the location arch/ arm/ lib/ bootm.c. So, this is the code of the U-Boot which actually picks up. You are Linux kernel from the memory and hands off the control to the Linux kernel. So, in this file, there is a function called boot-jump_linux. Here you can see that, they have defined a function pointer whose name is kernel entry. kernel_entry is a variable which is capable of holding a pointer to a function. kernel_entry is initialized to images. Under that there is a member called ep, that is entry point. That means, this function pointer is initialized to address, which is nothing but Linux entry point.

After that, what it does is, here you can see that, this code is basically storing the value of 'ft_addr' into the variable called 'r2'. So, the 'ft_addr', if you want to know what exactly is this, this is the RAM address at which the device tree binary is located. The device tree binary are that we call as DTB or FTT, that is Flattened device tree is actually a binary which actually describes the various peripherals present on the board. That binary is actually needed by the Linux kernel during the boot. Otherwise the Linux boot may not succeed. This is a very important line, where the U-Boot is dereferencing the kernel entry point. So, that means, this address is dereferenced. And along with that, it actually sends three important arguments. So, the first argument is 0. So, this is actually ignored by the Linux. And the second one is machine ID. The U-Boot is sending the machine ID information to the Linux. So, that means, it is saying that, "hey, I have detected this machine ID" and U-boot is passing that information to the Linux kernel. And 'r2' is where the fdt address is stored. So, when Linux comes to know about this machine ID, it will execute those initialization routines, which are required for this machine id. So, this is a point where the U-Boot is actually handing off control to the Linux kernel's bootstrap loader. This code actually calls the start routine in the head.s file of the bootstrap loader.
