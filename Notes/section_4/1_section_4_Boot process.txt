Section 4

Our target hardware is Beaglebone black and this board is powered by the SOC AM335x from Texas Instruments. AM335x is based on ARM cortex A8 processor.

Now, to run Linux on this embedded board, we need minimum of 4 software components. Here, the RBL stands for the ROM Boot Loader. That means, it's a very tiny boot loader runs out of the ROM memory of the SOC when you supply power to the board. This boot loader is written by the vendor. In our case, it's written by Texas Instruments and stored in the ROM of the SOC during taping out of the chip. So, we cannot change this boot loader. Also, we may not get the source code of this boot loader. This boot loader is very tiny and has limited functionalities. We cannot over write the functionalities written by this boot loader by changing the source code of this boot loader. The major job of the RBL is to load and execute the second stage boot loader from the internal memory ( SRAM ) of the SOC.

The second stage boot loader is also called as SPL. That stands for the Secondary Program Loader and some time it is also called as MLO, which stands for Memory Loader. The job of the second stage boot loader is to load and execute the third stage boot loader such as we boot from the DDR memory of the board. The job of the third stage boot loader is to load and execute the Linux kernel from the DDR memory of the board.

So, the booting actually takes place in 3 stages. RBL loading the SPL, SPL loading the U-boot and finally the U-Boot loading the kernel. And to complete the successful boot of the Linux, we also need a root file system for the Linux.

Read section 4:lec 21.

The SOC AM335x consists of ROM, that is Read Only Memory. The size of this ROM is very small. It's about only 176 KB enough to hold the ROM boot loader and the SOC also has small internal RAM memory, whose size is just 128 KB. So, when you give power to the SOC, it first undergoes the power on reset. And the ROM boot loader is the first software component to run on the SOC. The ROM code does the stack setup. Then calls the main function where first watchdog timer gets initialized. The watchdog timer is actually initialized for 3 minutes. That means, if the RBL could not able to load the second stage boot loader within 3 minutes, then the watchdog timer will expire and it will reset the processor. Then comes the very important initialization that is setting up the clock through the PLL. PLL stands for Phase-Locked Loop. Phase-Locked Loop is the clock generating engine by using which you can generate wide ranges of clock frequencies for different subsystems of the SOC. For the PLL, you have to give a low frequency clock source as an input, like a crystal oscillator and then the PLL will give you much higher output frequency which you can use to run your various subsystems of the SOC, like processor, display, peripherals, etc.. The ROM boot loader is loaded into the SOC during taping out of the chip. So, we cannot change it. The second stage boot loader is the phase where you can reconfigure the PLL to produce the frequencies which you like. Now RBL goes for the booting. Now it wants to load the second stage boot loader found in the external memory or peripherals. It will go through all the boot list and the loop is exited if a valid booting image is found and executed or upon the watchdog expiration. If it finds the second stage boot loader on the e-MMC memory of the board. Then the ROM code copies the MLO/SPL to the internal RAM of the SOC. The MLO or SPL will have its own image header. This image header is decided by TI itself. The RBL first reads the image header of the MLO. From the image header, it will get 2 important information. One is the load address and another one is the total size of the MLO. So, the RBL will load the MLO to the internal RAM address indicated by the image header of the MLO. After this stage, RBL's job is almost over.

MLO initializes the processor to a point that the third stage boot loader or U-Boot can be loaded into the external RAM, that is DDR memory device. So, some of the key work done by the MLO are, it does UART console initialization to printout the debug messages. It will reconfigure the PLL to the desired value, if it doesn't like the initialization done by the ROM boot loader. Then it initialize the DDR memory registers to use the DDR memory, because, MLOs job is actually to load the third stage boot loader such as the U-Boot into the external DDR memory. After that, the MLO does some muxing configurations of boot peripherals, because its next job is to load the U-boot. If MLO is going to get the U-Boot from the MMC0 or MMC1 interfaces lets say, then it will do the mux configurations to bring out the MMC0 or MMC1 functionalities on the pins, and it will also do the MMC peripheral related initialization. Then it copies the U-Boot image into the DDR memory and then it passes control to it. Again U-Boot also will have its own image header which indicates the load address and the size of the image to follow. So, the MLO loads the U-boot to the address as indicated by the U-Boot image header.

Remember that, MLO will not load the third stage boot loader like U-Boot to the internal RAM of the SOC. Because, the internal RAM is only of 128KB. U-boot obviously will not fit there. So, it copies it to the DDR memory which is external to the SOC.  One important question they ask is, why the ROM boot loader doesn't directly load U-boot into internal RAM? Why second stage boot loader is used? Because the size of the internal RAM in AM335x is 128KB. Out of which some 1KB of memory is considered as secure memory which cannot be used. And also some space is reserved for the purpose of stack and heap related activities. So, the available space will be lesser than the 128KB. So, that means, you have to squeeze in the U-Boot image to less than 128KB in order to store it into the internal RAM of the SOC. But, by considering all the required features of the U-Boot, it's almost not possible to reduce the U-Boot image to less than 128KB. So, that is the reason why we split this stage into 2. That is second stage boot loading and third stage boot loading. First what we do is, use secondary boot loader and run that to load and run the third stage boot loader such as U-boot from the external memory like DDR. 

And another interesting question is, can we use RBL to load the U-Boot directly into DDR memory of the board and skip using MLO or SPL? The reason why ROM boot loader of the AM335x SOC cannot load Uboot directly to DDD3 by skipping SPL is, ROM code wonâ€™t be having any idea about what kind of DDR RAM being used in the product to initialize it. DDR RAM is purely product/ board specific. So in the SPL/MLO, we get to know, what kind of DDR is connected to your product and based on that you have to change the SPL code , rebuild it and generate the binary to use it as the second stage boot loader.

--------------------------------------------------------------------------------------------------------------------------------
From Virtualbox connect with BBB using command: ssh debian@192.168.7.2. Then use temppwd as password
--------------------------------------------------------------------------------------------------------------------------------

In a U-boot, you can talk to your host PC over Ethernet over UART, USB, etc.. Major job of the u-boot is to load the Linux kernel from various boot sources to the DDR memory. The boot sources could be USB, it could be eMMC, SD card, Ethernet, or it could be via the serial port. Also we should provide one file called uEnv.txt, which consist of environmental variable values of the u-boot, which directs u-boot how to behave. So, u-boot looks for this file called uEnv.txt reads it and behaves according to the value set in the environmental variables of the file. We can override any default u-boot behavior by using this file. uImage is nothing but zImage plus u-boot header. zImage is elf binary format of the Linux kernel and if you append the u-boot header to it, it's called uImage. From the image header, u-boot gets lot of information about the Linux kernel.This header is of 64 bytes in total, so you can even count this structure bytes, total bytes of this structure. So, that turns out to be 64 bytes.

ROOTFS partition of the SD card consist of the root file system and u-boot is supposed to load the Linux kernel. But u-boot has no idea where exactly the Linux kernel is actually residing in the SD card. So, the Linux kernel image is actually present in the boot folder of the second partition, but the u-boot has no idea. So, that is the reason we have to use uEnv.txt file to tell u-boot where exactly the Linux kernel is present. It's a very simple file, which consist of variable and a value pair.

At boot, you can see that, here the U-Boot ran and it detected that the mmc0 interface is present, that is actually our SD card. So, that means, the U-Boot has detected the mmc interface, and then it printed that "MMC is found on device 0". It read our uEnv.txt file. So, that's about 371 bytes. After that, it ran the environment variable 'uenvcmd'. This environmental variable is actually a collection of couple of other U-Boot commands. So, until here it is u-boot and from here onwards it is Linux bootstrap loader. There is a file called miscellaneous.c, which is part of the Linux bootstrap loader, which takes care of uncompressing the Linux kernel. ( image at 3:37 lec 20 )
