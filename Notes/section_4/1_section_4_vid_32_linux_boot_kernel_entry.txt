From the bootstrap loader the control then comes to this head.S file And remember that, this is also architecture specific code. now let's open this 'head.s' in the Linux kernel source. Here you can see that this is the entry point. And if you read these comments you can make out something. It says that. this is normally called from the decompressor code. That means, from the bootstrap loader, which actually did the decompression of the kernel and triggered the execution of the decompressed kernel.

at this point to the MMU is off. That means, no virtual addressing being enabled. Because, we are still in the initialization phase of our hardware. And the D-cache is off. I-cache of the processor is also off. The register r0 contains 0 And the register r1 must contain the value of the machine id. So, every board will have unique machine id. So, the R1 must contain that. Because, this file uses the machine id to carry out the machine specific initialization and the register r2 will hold the address of the device tree binary which is present there on your RAM.

let's explore some of the important sub routines called by this file. Check for proper processor type. This call will search for the processor architecture present on the board. After knowing the processor type, then it calls the appropriate processor specific initialization routines found in the respective processor specific files in the path arch/arm/mm OK? So, mm stands for memory management. Let's have a look in arch/arm/mm directory. Here you can see that, every processor has its own processor specific initialization file. For example, this is for arm7tdmi. This is for arm9, for arm10, for arm version 7 based processors like Cortex A8. Basically the processor specific calls are made to deal with the memory management unit as explained here in these comments. Also note that, the register r10 holds the processor info structure related to a processor which is detected by the call lookup_processor_type previously.

And this comment says that on return, the CPU will be ready for the memory management unit to be turned So, which confirms that all the processor specific calls are made to initialize the mmu before turning it ON. that means, before giving control to the Linux generic code, mmu initialization and turning on of the MMU is must. That's the duty of these architecture specific codes. Another important assembly subroutine is enable MMU. So, which initializes the page table pointers and turn on the MMU, so that the kernel can start running with virtual address support. So, after that, a function called start kernel is called from the file head- common.S located in the same path arch/arm/kernel. Now, from here the flow control comes to the file main.c of the Linux kernel.
