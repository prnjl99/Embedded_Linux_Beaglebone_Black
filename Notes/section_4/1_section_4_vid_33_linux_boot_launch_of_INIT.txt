The functions start kernel is a C function implemented in architecture independent generic file that is main.c found in this path, Init/main.c. at this point, all the architecture depending initializations are over, your CPU is ready with the MMU support and Linux is all set to do architecture independent kernel initialization. let's go to the function start_kernel in the file main.c and explore what it does.

But before that, lets conclude what we learnt. So, first of all, the head.s belongs to the Linux kernel architecture specific code, mostly it does CPU specific initializations of the SOC. in this case ARM cortex- A8 is the CPU. And if you analyze the code of head.s, it's particularly interested in searching of CPU type like whether it belongs to ARM 9 or ARM 10 or ARM cortex A8, etc. And once it comes to know about the architecture type, it majorly initializes the MMU and creates the initial page table entries and then enables the MMU of the processor for virtual memory support, before giving control to the main.c file of the Linux kernel which is the generic one.

now let's explore the function start_kernel() in init main.c. main.c code does all the startup work for the Linux kernel from initializing the very first kernel thread , all the way to mounting a root file system and executing the very first user space Linux application program. The entry point into this main.c is start kernel function which is a very huge function calling lots of other initialization functions. Here the kernel prints the linux_banner string, which you can identify in the log over here. The linux_banner string you can find here in the file init version.c lets go ahead and open version.c and you can locate over here. So, it actually prints the linux version, the compiler version, the date of compilation, the build number, etc.. After that, start kernel does lots of early initialization of the Linux kernel such as extracting the command line arguments sent by the boot loader, initialization of the console to get the error messages, Memory management initialization, scheduler initialization, timer initialization, high resolution timer initialization, software IRQ initialization, etc.. So, basically it initializes various subsystems of a Linux kernel before mounting the root file system and launching the very first Linux application. You can learn more by going through all these helper functions one by one and exploring what exactly they do. So, after that, at the end it calls a function called rest_init(). Now, we are very close to launching our first program that is init. here it is creating 2 kernel threads; one is called kernel_init and another one is called kthreadd. After that, here, it is starting the scheduler and then kernel is going to CPU idle loop. This is actually a infinite loop while (1). here, take a look into this comments. We need to spawn init first, so that, it obtains pid 1, however the init task will end up wanting to create kthreads which, if we schedule it before we create kthreadd, will result in the OOPS. That means, first they are creating a kernel thread called kernel_init, which will get the pid number 1 and then they are creating another kernel thread called kthreadd, which will get the pid number 2. So, actually there are two kernel threads got created. The kernel_init kernel thread will then execute the very first user application called init. So, that's the reason init application actually inherits its kernel threads pid number, that is 1. kthreadd kernel thread is used to spawn other kernel threads.

So, let me explain again. kernel_init is a kernel thread which is used to spawn the very first Linux application that is init. And kthreadd is also another kernel thread which is used to spawn other kernel threads. let's go to this function kernel_init. This function free_initmem, actually reclaims the memory which are being used by the initialization function so far. Because, those functions are no longer needed. that's the reason all the initialization function memory will be reclaimed. because once the Linux initialization is done, no one going to call those functions. that's the reason you get to this kernel log free_initmem. that means, this much of memory of the RAM is reclaimed by the kernel and it can be used for some other purpose. After that, it tries to run the init application. If this fails, it tries this. If this also fails, then it comes over here, and tries these options one by one. First it tries to execute the program from this location, in the root file system. If it fails to find the init at this location, it tries at other locations. And if no init is found, then it simply executes the shell application which is present in the root file system and just returns.

If none of these programs found in these location, then it actually throws an error "no init found", OK? And note that you can also mention the path of the init program by using the Linux command line argument called init. init is equal to you have to give the path of the init program, if you have any customized or some other path. So, in that case, it checks the execute command first over here. which comes from the kernel command line argument init is equal to parameter. So, that's how the Linux finally launches the user application. Either it launches the init or if no init found then at least it will launch the shell application.

So, that's how the control comes all the way from boot loaders to Linux bootstrap loader to linux kernel to launching of the very first application. And init is a application which is responsible for launching other applications.
