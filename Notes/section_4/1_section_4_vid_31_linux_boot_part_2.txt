according to this flow control diagram, the boot loader actually hands off control to the bootstrap loader. The the file name is actually head.s and the routine name is start. So, let me go to my Linux source. I have just given the link in the resource section. From there you can clone the Linux source code. it is the architecture specific code. arch / arm/ boot/ compressed/ head.s So, all bootstrap loader related files are actually present in the folder compressed.let's open this file and and let's search for 'start:' So, this is a routine at which the control arrives from the U-Boot, that is from here. So, this is the U-boot code where we just dereferenced the entry point address. the control arrives at this routine. 'start' is a place where the control comes from U-boot to the bootstrap loader of the Linux kernel and it does lot of assembly related activities,

Honestly speaking, I'm not thoroughly understood what exactly these codes actually do. But, if you invest a lot of time, so you will definitely understand. For example, here you can see these two lines of code where it is actually saving the architecture ID that is nothing but the machine id and the dtb address. It is actually saving it to register r7 and r8. So, here if you go back to U-boot, here you can see that, when we dereference the entry point address, we also send three arguments, isn't it? so, the first argument is stored in r0, that is in the register r0. the second argument is stored in the register r1 and the third argument is stored in the register r2. that is nothing but a machine ID and DTB address.

after that what happens is- the head.s file of the bootstrap loader calls the misc.c file in order to decompress the kernel. just search the word 'decompress_kernel' in this file. So, here you can see, there is a branching happening to the decompress_kernel. this code is actually written in misc.c. this is a misc.c and here search for decompress_kernel. OK? So, here is a function which actually decompresses your kernel. This is uncompressing Linux output, which you see in this log. So, here you can see uncompressing Linux, done booting the kernel.

after that what the next step- the control after that will be passed from head.s of the bootstrap loader to another head.s of the Linux kernel. So, that we can locate in the file arch/ arm/kernel/ e on kernel/head.s.

Let's quickly conclude what we have learnt in this lecture to avoid confusion. The first thing is handing off of control from U-boot to Linux bootstrap loader. This is done in the file bootm.c of the U-boot source code. Then the control arrives to the head.s file at the routine start of the bootstrap loader. After that, head.s calls decompress kernel function which is implemented in the misc.c OK? After that control comes to another head.s file which belongs to the Linux kernel located in arch/ arm/ kernel folder of the Linux source code. this head.s is actually architecture specific code. It's not depending upon any SOC family. It's a generic startup code for arm processors. It does arm specific initialization such as instruction and data cache, initialization, exception an interrupt setup, and other low level initialization, which are required for the successful boot of the Linux kernel image. This head.s executes lots of architecture specific initialization codes implemented in different intermediate files which I have not shown. And also remember that the uncompression and relocation of the Linux kernel image is not the responsibility of the U-Boot. It's the responsibility of the bootstrap loader which is glued to the Linux kernel image. And there are two files of the same name head.s Don't be confused. One belongs to the bootstrap loader and another one belongs to the Linux kernel. And remember that both are architecture dependent.
